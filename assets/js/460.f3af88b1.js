(self.webpackChunk_react_mol_docs=self.webpackChunk_react_mol_docs||[]).push([[460],{43460:function(e,t,r){"use strict";r.d(t,{O:function(){return n}});var o=r(12955);class n{static computeTangents(e){e.computeTangents(),console.warn("THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.")}static mergeBufferGeometries(e,t=!1){const r=null!==e[0].index,n=new Set(Object.keys(e[0].attributes)),s=new Set(Object.keys(e[0].morphAttributes)),i={},u={},a=e[0].morphTargetsRelative,l=new o.BufferGeometry;let f=0;for(let o=0;o<e.length;++o){const m=e[o];let c=0;if(r!==(null!==m.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const e in m.attributes){if(!n.has(e))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;void 0===i[e]&&(i[e]=[]),i[e].push(m.attributes[e]),c++}if(c!==n.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+". Make sure all geometries have the same number of attributes."),null;if(a!==m.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const e in m.morphAttributes){if(!s.has(e))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===u[e]&&(u[e]=[]),u[e].push(m.morphAttributes[e])}if(l.userData.mergedUserData=l.userData.mergedUserData||[],l.userData.mergedUserData.push(m.userData),t){let e;if(r)e=m.index.count;else{if(void 0===m.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+". The geometry must have either an index or a position attribute"),null;e=m.attributes.position.count}l.addGroup(f,e,o),f+=e}}if(r){let t=0;const r=[];for(let o=0;o<e.length;++o){const n=e[o].index;for(let e=0;e<n.count;++e)r.push(n.getX(e)+t);t+=e[o].attributes.position.count}l.setIndex(r)}for(const o in i){const e=this.mergeBufferAttributes(i[o]);if(!e)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+o+" attribute."),null;l.setAttribute(o,e)}for(const o in u){const e=u[o][0].length;if(0===e)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[o]=[];for(let t=0;t<e;++t){const e=[];for(let n=0;n<u[o].length;++n)e.push(u[o][n][t]);const r=this.mergeBufferAttributes(e);if(!r)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+o+" morphAttribute."),null;l.morphAttributes[o].push(r)}}return l}static mergeBufferAttributes(e){let t,r,n,s=0;for(let o=0;o<e.length;++o){const i=e[o];if(i.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===t&&(t=i.array.constructor),t!==i.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===r&&(r=i.itemSize),r!==i.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===n&&(n=i.normalized),n!==i.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;s+=i.array.length}const i=new t(s);let u=0;for(let o=0;o<e.length;++o)i.set(e[o].array,u),u+=e[o].array.length;return new o.BufferAttribute(i,r,n)}static interleaveAttributes(e){let t,r=0,n=0;for(let o=0,f=e.length;o<f;++o){const s=e[o];if(void 0===t&&(t=s.array.constructor),t!==s.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;r+=s.array.length,n+=s.itemSize}const s=new o.InterleavedBuffer(new t(r),n);let i=0;const u=[],a=["getX","getY","getZ","getW"],l=["setX","setY","setZ","setW"];for(let f=0,m=e.length;f<m;f++){const t=e[f],r=t.itemSize,n=t.count,m=new o.InterleavedBufferAttribute(s,r,i,t.normalized);u.push(m),i+=r;for(let e=0;e<n;e++)for(let o=0;o<r;o++)m[l[o]](e,t[a[o]](e))}return u}static estimateBytesUsed(e){let t=0;for(const o in e.attributes){const r=e.getAttribute(o);t+=r.count*r.itemSize*r.array.BYTES_PER_ELEMENT}const r=e.getIndex();return t+=r?r.count*r.itemSize*r.array.BYTES_PER_ELEMENT:0,t}static mergeVertices(e,t=1e-4){t=Math.max(t,Number.EPSILON);const r={},n=e.getIndex(),s=e.getAttribute("position"),i=n?n.count:s.count;let u=0;const a=Object.keys(e.attributes),l={},f={},m=[],c=["getX","getY","getZ","getW"];for(let o=0,b=a.length;o<b;o++){const t=a[o];l[t]=[];const r=e.morphAttributes[t];r&&(f[t]=new Array(r.length).fill().map((()=>[])))}const g=Math.log10(1/t),d=Math.pow(10,g);for(let o=0;o<i;o++){const t=n?n.getX(o):o;let s="";for(let r=0,o=a.length;r<o;r++){const o=a[r],n=e.getAttribute(o),i=n.itemSize;for(let e=0;e<i;e++)s+=~~(n[c[e]](t)*d)+","}if(s in r)m.push(r[s]);else{for(let r=0,o=a.length;r<o;r++){const o=a[r],n=e.getAttribute(o),s=e.morphAttributes[o],i=n.itemSize,u=l[o],m=f[o];for(let e=0;e<i;e++){const r=c[e];if(u.push(n[r](t)),s)for(let e=0,o=s.length;e<o;e++)m[e].push(s[e][r](t))}}r[s]=u,m.push(u),u++}}const h=e.clone();for(let b=0,p=a.length;b<p;b++){const t=a[b],r=e.getAttribute(t),n=new r.array.constructor(l[t]),s=new o.BufferAttribute(n,r.itemSize,r.normalized);if(h.setAttribute(t,s),t in f)for(let i=0;i<f[t].length;i++){const r=e.morphAttributes[t][i],n=new r.array.constructor(f[t][i]),s=new o.BufferAttribute(n,r.itemSize,r.normalized);h.morphAttributes[t][i]=s}}return h.setIndex(m),h}static toTrianglesDrawMode(e,t){if(t===o.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t===o.TriangleFanDrawMode||t===o.TriangleStripDrawMode){let r=e.getIndex();if(null===r){const t=[],o=e.getAttribute("position");if(void 0===o)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<o.count;e++)t.push(e);e.setIndex(t),r=e.getIndex()}const n=r.count-2,s=[];if(t===o.TriangleFanDrawMode)for(let e=1;e<=n;e++)s.push(r.getX(0)),s.push(r.getX(e)),s.push(r.getX(e+1));else for(let e=0;e<n;e++)e%2==0?(s.push(r.getX(e)),s.push(r.getX(e+1)),s.push(r.getX(e+2))):(s.push(r.getX(e+2)),s.push(r.getX(e+1)),s.push(r.getX(e)));s.length/3!==n&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=e.clone();return i.setIndex(s),i.clearGroups(),i}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e}static computeMorphedAttributes(e){if(!0!==e.geometry.isBufferGeometry)return console.error("THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry."),null;const t=new o.Vector3,r=new o.Vector3,n=new o.Vector3,s=new o.Vector3,i=new o.Vector3,u=new o.Vector3,a=new o.Vector3,l=new o.Vector3,f=new o.Vector3;function m(e,o,m,c,g,d,h,b,p){t.fromBufferAttribute(m,d),r.fromBufferAttribute(m,h),n.fromBufferAttribute(m,b);const y=e.morphTargetInfluences;if(o.morphTargets&&c&&y){a.set(0,0,0),l.set(0,0,0),f.set(0,0,0);for(let e=0,o=c.length;e<o;e++){const o=y[e],m=c[e];0!==o&&(s.fromBufferAttribute(m,d),i.fromBufferAttribute(m,h),u.fromBufferAttribute(m,b),g?(a.addScaledVector(s,o),l.addScaledVector(i,o),f.addScaledVector(u,o)):(a.addScaledVector(s.sub(t),o),l.addScaledVector(i.sub(r),o),f.addScaledVector(u.sub(n),o)))}t.add(a),r.add(l),n.add(f)}e.isSkinnedMesh&&(e.boneTransform(d,t),e.boneTransform(h,r),e.boneTransform(b,n)),p[3*d+0]=t.x,p[3*d+1]=t.y,p[3*d+2]=t.z,p[3*h+0]=r.x,p[3*h+1]=r.y,p[3*h+2]=r.z,p[3*b+0]=n.x,p[3*b+1]=n.y,p[3*b+2]=n.z}const c=e.geometry,g=e.material;let d,h,b;const p=c.index,y=c.attributes.position,A=c.morphAttributes.position,B=c.morphTargetsRelative,w=c.attributes.normal,E=c.morphAttributes.position,T=c.groups,G=c.drawRange;let x,S,U,v,M,R,z,X;const H=new Float32Array(y.count*y.itemSize),D=new Float32Array(w.count*w.itemSize);if(null!==p)if(Array.isArray(g))for(x=0,U=T.length;x<U;x++)for(M=T[x],R=g[M.materialIndex],z=Math.max(M.start,G.start),X=Math.min(M.start+M.count,G.start+G.count),S=z,v=X;S<v;S+=3)d=p.getX(S),h=p.getX(S+1),b=p.getX(S+2),m(e,R,y,A,B,d,h,b,H),m(e,R,w,E,B,d,h,b,D);else for(z=Math.max(0,G.start),X=Math.min(p.count,G.start+G.count),x=z,U=X;x<U;x+=3)d=p.getX(x),h=p.getX(x+1),b=p.getX(x+2),m(e,g,y,A,B,d,h,b,H),m(e,g,w,E,B,d,h,b,D);else if(void 0!==y)if(Array.isArray(g))for(x=0,U=T.length;x<U;x++)for(M=T[x],R=g[M.materialIndex],z=Math.max(M.start,G.start),X=Math.min(M.start+M.count,G.start+G.count),S=z,v=X;S<v;S+=3)d=S,h=S+1,b=S+2,m(e,R,y,A,B,d,h,b,H),m(e,R,w,E,B,d,h,b,D);else for(z=Math.max(0,G.start),X=Math.min(y.count,G.start+G.count),x=z,U=X;x<U;x+=3)d=x,h=x+1,b=x+2,m(e,g,y,A,B,d,h,b,H),m(e,g,w,E,B,d,h,b,D);return{positionAttribute:y,normalAttribute:w,morphedPositionAttribute:new o.Float32BufferAttribute(H,3),morphedNormalAttribute:new o.Float32BufferAttribute(D,3)}}}}}]);